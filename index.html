<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="xr-spatial-tracking" content="true">
    <title>AR Tetris Pro</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body, html {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            color: #fff;
            touch-action: none;
        }

        #ar-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        #game-hud {
            position: absolute;
            top: 15px;
            left: 15px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 101;
        }

        .hud-panel {
            background: rgba(25, 25, 45, 0.85);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 12px 18px;
            border: 1px solid rgba(100, 150, 255, 0.2);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .hud-header {
            font-size: 14px;
            color: #a0a0ff;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .hud-value {
            font-size: 24px;
            font-weight: 700;
            color: #fff;
        }

        #next-piece {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 80px;
            height: 80px;
            background: rgba(25, 25, 45, 0.85);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            border: 1px solid rgba(100, 150, 255, 0.2);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            overflow: hidden;
        }

        #next-piece-label {
            font-size: 12px;
            color: #a0a0ff;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #next-piece-canvas {
            width: 60px;
            height: 60px;
        }

        #ar-button {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
            color: white;
            border: none;
            padding: 16px 40px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 6px 25px rgba(37, 117, 252, 0.5);
            z-index: 102;
            pointer-events: auto;
            transition: all 0.3s ease;
        }

        #ar-button:hover {
            transform: translateX(-50%) scale(1.05);
            box-shadow: 0 8px 30px rgba(37, 117, 252, 0.7);
        }

        #placement-hint {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(15, 15, 30, 0.85);
            backdrop-filter: blur(10px);
            padding: 15px 30px;
            border-radius: 15px;
            text-align: center;
            max-width: 90%;
            border: 1px solid rgba(100, 150, 255, 0.2);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            display: none;
            z-index: 102;
            pointer-events: none;
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(15, 15, 30, 0.95);
            backdrop-filter: blur(20px);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
            z-index: 103;
            width: 90%;
            max-width: 400px;
            border: 1px solid rgba(255, 80, 80, 0.3);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            pointer-events: auto;
        }

        #game-over h2 {
            font-size: 32px;
            color: #ff5555;
            margin-bottom: 15px;
        }

        #final-score {
            font-size: 26px;
            font-weight: 700;
            margin: 20px 0;
        }

        #restart-button {
            background: linear-gradient(135deg, #00c853 0%, #009624 100%);
            color: white;
            border: none;
            padding: 14px 35px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 6px 20px rgba(0, 200, 83, 0.4);
            transition: all 0.3s ease;
            margin-top: 10px;
        }

        #restart-button:hover {
            transform: scale(1.05);
            box-shadow: 0 8px 25px rgba(0, 200, 83, 0.5);
        }

        #controls-hint {
            position: absolute;
            bottom: 160px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(15, 15, 30, 0.85);
            backdrop-filter: blur(10px);
            padding: 14px 20px;
            border-radius: 15px;
            text-align: center;
            max-width: 90%;
            border: 1px solid rgba(100, 150, 255, 0.2);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            display: none;
            z-index: 101;
            pointer-events: none;
            font-size: 14px;
            line-height: 1.5;
        }

        #controls-hint div {
            margin: 5px 0;
        }

        .control-direction {
            display: inline-block;
            background: rgba(100, 150, 255, 0.2);
            border-radius: 5px;
            padding: 2px 8px;
            margin: 0 3px;
        }

        #loading {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(10, 10, 20, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
        }

        .loader {
            width: 60px;
            height: 60px;
            border: 5px solid rgba(100, 150, 255, 0.2);
            border-radius: 50%;
            border-top-color: #6a11cb;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        #loading-text {
            font-size: 18px;
            color: #a0a0ff;
            text-align: center;
            max-width: 80%;
        }

        @media (max-width: 768px) {
            #game-hud {
                top: 10px;
                left: 10px;
            }
            
            .hud-panel {
                padding: 10px 15px;
            }
            
            .hud-value {
                font-size: 20px;
            }
            
            #next-piece {
                top: 10px;
                right: 10px;
                width: 70px;
                height: 70px;
            }
            
            #next-piece-canvas {
                width: 50px;
                height: 50px;
            }
            
            #ar-button {
                padding: 14px 35px;
                font-size: 16px;
            }
            
            #game-over {
                padding: 30px;
            }
            
            #game-over h2 {
                font-size: 28px;
            }
            
            #final-score {
                font-size: 22px;
            }
        }
    </style>
</head>
<body>
    <!-- Loading Screen -->
    <div id="loading">
        <div class="loader"></div>
        <div id="loading-text">Loading AR Tetris Pro...</div>
    </div>

    <!-- AR Container -->
    <div id="ar-container"></div>
    
    <!-- Game UI -->
    <div id="ui-overlay">
        <div id="game-hud">
            <div class="hud-panel">
                <div class="hud-header">Score</div>
                <div id="score" class="hud-value">0</div>
            </div>
            <div class="hud-panel">
                <div class="hud-header">Level</div>
                <div id="level" class="hud-value">1</div>
            </div>
        </div>
        
        <div id="next-piece">
            <div id="next-piece-label">Next</div>
            <canvas id="next-piece-canvas"></canvas>
        </div>
        
        <button id="ar-button">START AR EXPERIENCE</button>
        
        <div id="placement-hint">
            Move your device to find a flat surface, then tap to place the game board.
        </div>
        
        <div id="controls-hint">
            <div><span class="control-direction">LEFT</span> Tap left side to move left</div>
            <div><span class="control-direction">RIGHT</span> Tap right side to move right</div>
            <div><span class="control-direction">CENTER</span> Tap to rotate</div>
            <div><span class="control-direction">DOWN</span> Swipe down to drop</div>
        </div>
        
        <div id="game-over">
            <h2>GAME OVER</h2>
            <p>Your Final Score</p>
            <div id="final-score">0</div>
            <button id="restart-button">PLAY AGAIN</button>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.165.0/examples/jsm/webxr/ARButton.js';

        // Game Constants
        const BOARD_SIZE = 2.0; // 2 meters in real world
        const BOARD_WIDTH = 10;
        const BOARD_HEIGHT = 20;
        const BLOCK_SIZE = BOARD_SIZE / BOARD_WIDTH;
        
        // Tetromino shapes with rotations
        const SHAPES = [
            // I-piece
            [[1, 1, 1, 1]],
            // O-piece
            [[1, 1], [1, 1]],
            // T-piece
            [[0, 1, 0], [1, 1, 1]],
            // S-piece
            [[0, 1, 1], [1, 1, 0]],
            // Z-piece
            [[1, 1, 0], [0, 1, 1]],
            // L-piece
            [[1, 0], [1, 0], [1, 1]],
            // J-piece
            [[0, 1], [0, 1], [1, 1]]
        ];
        
        // Colors for each tetromino
        const COLORS = [
            0x00F0F0, // I - Cyan
            0xF0F000, // O - Yellow
            0xA000F0, // T - Purple
            0x00F000, // S - Green
            0xF00000, // Z - Red
            0x0000F0, // L - Blue
            0xF0A000  // J - Orange
        ];
        
        // Level speeds (milliseconds between drops)
        const LEVEL_SPEEDS = [1000, 850, 700, 550, 450, 350, 280, 220, 180, 150];
        
        // Game variables
        let renderer, scene, camera;
        let gameBoard, placementGrid;
        let currentPiece, nextPieceType;
        let hitTestSource = null;
        let grid = [];
        let score = 0, level = 1, gameActive = false;
        let gameLoopInterval = null;
        let audioEnabled = false;
        let sessionStarted = false;
        
        // DOM elements
        const arContainer = document.getElementById('ar-container');
        const arButton = document.getElementById('ar-button');
        const placementHint = document.getElementById('placement-hint');
        const gameOverScreen = document.getElementById('game-over');
        const restartButton = document.getElementById('restart-button');
        const finalScoreElement = document.getElementById('final-score');
        const scoreElement = document.getElementById('score');
        const levelElement = document.getElementById('level');
        const nextPieceCanvas = document.getElementById('next-piece-canvas');
        const nextPieceCtx = nextPieceCanvas.getContext('2d');
        const controlsHint = document.getElementById('controls-hint');
        const loadingScreen = document.getElementById('loading');
        
        // Initialize the game
        async function init() {
            try {
                // Initialize scene
                scene = new THREE.Scene();
                
                // Initialize camera
                camera = new THREE.PerspectiveCamera(
                    70, 
                    window.innerWidth / window.innerHeight, 
                    0.01, 
                    20
                );
                camera.position.set(0, 1, 0);
                
                // Setup lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
                directionalLight.position.set(1, 1, 1);
                scene.add(directionalLight);
                
                // Initialize renderer
                renderer = new THREE.WebGLRenderer({ 
                    antialias: true, 
                    alpha: true,
                    powerPreference: "high-performance"
                });
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.xr.enabled = true;
                arContainer.appendChild(renderer.domElement);
                
                // Create placement grid
                const gridGeometry = new THREE.PlaneGeometry(BOARD_SIZE, BOARD_SIZE);
                const gridMaterial = new THREE.MeshBasicMaterial({
                    color: 0x0099ff,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.5
                });
                placementGrid = new THREE.Mesh(gridGeometry, gridMaterial);
                placementGrid.rotation.x = -Math.PI / 2;
                placementGrid.visible = false;
                scene.add(placementGrid);
                
                // Create game board group
                gameBoard = new THREE.Group();
                
                // Initialize grid
                resetGrid();
                
                // Setup event listeners
                arButton.addEventListener('click', startARSession);
                restartButton.addEventListener('click', restartGame);
                
                // Setup touch controls
                renderer.domElement.addEventListener('touchstart', handleTouchStart, { passive: false });
                renderer.domElement.addEventListener('touchmove', handleTouchMove, { passive: false });
                renderer.domElement.addEventListener('touchend', handleTouchEnd, { passive: false });
                
                // Handle window resize
                window.addEventListener('resize', onWindowResize);
                
                // Hide loading screen after a short delay
                setTimeout(() => {
                    loadingScreen.style.display = 'none';
                }, 1500);
                
                console.log("Game initialized successfully");
            } catch (error) {
                console.error("Initialization error:", error);
                loadingScreen.innerHTML = `
                    <div style="color: #ff5555; font-size: 20px; margin-bottom: 20px;">Initialization Error</div>
                    <div style="margin-bottom: 20px;">${error.message}</div>
                    <button onclick="location.reload()" style="background: #6a11cb; color: white; border: none; padding: 12px 25px; border-radius: 25px; cursor: pointer;">
                        Reload Page
                    </button>
                `;
            }
        }
        
        // Start AR session
        async function startARSession() {
            try {
                console.log("Starting AR session...");
                
                // Create the AR button
                const defaultARButton = ARButton.createButton(renderer, {
                    requiredFeatures: ['hit-test'],
                    optionalFeatures: ['dom-overlay'],
                    domOverlay: { root: document.body }
                });
                defaultARButton.id = "default-ar-button";
                defaultARButton.style.display = 'none';
                document.body.appendChild(defaultARButton);
                
                // Attempt to start AR session
                defaultARButton.click();
                sessionStarted = true;
                
                // Show placement hint
                placementHint.style.display = 'block';
                
                // Setup session event listeners
                renderer.xr.addEventListener('sessionstart', onSessionStart);
                renderer.xr.addEventListener('sessionend', onSessionEnd);
                
                // Start animation loop
                renderer.setAnimationLoop(animate);
                
                console.log("AR session started");
            } catch (error) {
                console.error("AR session failed to start:", error);
                placementHint.textContent = "AR not supported on this device. Please try on a compatible mobile device.";
            }
        }
        
        // Handle AR session start
        async function onSessionStart() {
            try {
                const session = renderer.xr.getSession();
                console.log("AR session started");
                
                // Request hit test source
                const referenceSpace = await session.requestReferenceSpace('viewer');
                hitTestSource = await session.requestHitTestSource({ space: referenceSpace });
                
                // Setup select event for placing board
                session.addEventListener('select', placeGameBoard);
                
                // Update UI
                arButton.style.display = 'none';
                placementHint.style.display = 'block';
                
                // Initialize audio
                initAudio();
            } catch (error) {
                console.error("Session start error:", error);
            }
        }
        
        // Handle AR session end
        function onSessionEnd() {
            console.log("AR session ended");
            resetGameState();
            location.reload();
        }
        
        // Initialize audio
        function initAudio() {
            console.log("Initializing audio system");
            audioEnabled = true;
        }
        
        // Play sound effect
        function playSound(type) {
            if (!audioEnabled) return;
            console.log(`Playing sound: ${type}`);
            // In a real implementation, you would play the actual audio files here
        }
        
        // Reset game grid
        function resetGrid() {
            grid = [];
            for (let row = 0; row < BOARD_HEIGHT; row++) {
                grid[row] = Array(BOARD_WIDTH).fill(0);
            }
        }
        
        // Reset game state
        function resetGameState() {
            clearInterval(gameLoopInterval);
            gameActive = false;
            score = 0;
            level = 1;
            
            // Remove all pieces
            while (gameBoard.children.length > 0) {
                gameBoard.remove(gameBoard.children[0]);
            }
            
            // Reset grid
            resetGrid();
            
            // Update UI
            scoreElement.textContent = '0';
            levelElement.textContent = '1';
            gameOverScreen.style.display = 'none';
            controlsHint.style.display = 'none';
        }
        
        // Start the game
        function startGame() {
            console.log("Starting game");
            gameActive = true;
            
            // Initialize next piece
            nextPieceType = Math.floor(Math.random() * SHAPES.length);
            renderNextPiece();
            
            // Spawn first piece
            spawnPiece();
            
            // Start game loop
            gameLoopInterval = setInterval(() => {
                if (currentPiece) {
                    movePieceDown();
                }
            }, LEVEL_SPEEDS[level - 1]);
            
            // Show controls hint
            controlsHint.style.display = 'block';
            
            // Play background music
            playSound('bgm');
        }
        
        // Render next piece preview
        function renderNextPiece() {
            nextPieceCtx.clearRect(0, 0, nextPieceCanvas.width, nextPieceCanvas.height);
            
            // Get shape information
            const shape = SHAPES[nextPieceType][0];
            const color = COLORS[nextPieceType];
            const hexColor = `#${color.toString(16).padStart(6, '0')}`;
            
            // Calculate block size
            const blockSize = Math.min(
                nextPieceCanvas.width / (shape[0].length + 2),
                nextPieceCanvas.height / (shape.length + 2)
            );
            
            // Calculate offset to center shape
            const offsetX = (nextPieceCanvas.width - shape[0].length * blockSize) / 2;
            const offsetY = (nextPieceCanvas.height - shape.length * blockSize) / 2;
            
            // Draw shape with glow effect
            nextPieceCtx.shadowColor = hexColor;
            nextPieceCtx.shadowBlur = 10;
            nextPieceCtx.fillStyle = hexColor;
            
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col]) {
                        nextPieceCtx.fillRect(
                            offsetX + col * blockSize,
                            offsetY + row * blockSize,
                            blockSize - 2,
                            blockSize - 2
                        );
                    }
                }
            }
            
            // Reset shadow
            nextPieceCtx.shadowBlur = 0;
        }
        
        // Spawn a new piece
        function spawnPiece() {
            const typeIndex = nextPieceType;
            nextPieceType = Math.floor(Math.random() * SHAPES.length);
            renderNextPiece();
            
            const shape = SHAPES[typeIndex][0];
            const color = COLORS[typeIndex];
            
            const piece = new THREE.Group();
            piece.userData = {
                typeIndex,
                shape,
                rotation: 0,
                position: {
                    x: Math.floor(BOARD_WIDTH / 2 - shape[0].length / 2),
                    y: 0
                }
            };
            
            // Create piece geometry
            const blockGeometry = new THREE.BoxGeometry(
                BLOCK_SIZE * 0.9,
                BLOCK_SIZE * 0.9,
                BLOCK_SIZE * 0.9
            );
            
            const blockMaterial = new THREE.MeshPhongMaterial({
                color: color,
                shininess: 30,
                emissive: color,
                emissiveIntensity: 0.1
            });
            
            // Create individual blocks
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col]) {
                        const block = new THREE.Mesh(blockGeometry, blockMaterial);
                        block.position.set(
                            col * BLOCK_SIZE - (shape[0].length * BLOCK_SIZE) / 2 + BLOCK_SIZE / 2,
                            -row * BLOCK_SIZE + (shape.length * BLOCK_SIZE) / 2 - BLOCK_SIZE / 2,
                            0
                        );
                        piece.add(block);
                    }
                }
            }
            
            // Position the piece
            updatePiecePosition(piece);
            
            // Add to game board
            gameBoard.add(piece);
            currentPiece = piece;
            
            // Check if game over (piece can't be placed)
            if (!isValidMove(currentPiece, 0, 0)) {
                gameOver();
            }
        }
        
        // Update piece position
        function updatePiecePosition(piece) {
            const ud = piece.userData;
            piece.position.set(
                (ud.position.x - BOARD_WIDTH / 2 + 0.5) * BLOCK_SIZE,
                (BOARD_HEIGHT / 2 - 0.5 - ud.position.y) * BLOCK_SIZE,
                0
            );
        }
        
        // Move piece down
        function movePieceDown() {
            if (isValidMove(currentPiece, 0, 1)) {
                currentPiece.userData.position.y += 1;
                updatePiecePosition(currentPiece);
            } else {
                lockPiece();
                spawnPiece();
            }
        }
        
        // Check if move is valid
        function isValidMove(piece, dx, dy) {
            const ud = piece.userData;
            const newX = ud.position.x + dx;
            const newY = ud.position.y + dy;
            
            // Check boundaries
            for (let row = 0; row < ud.shape.length; row++) {
                for (let col = 0; col < ud.shape[row].length; col++) {
                    if (ud.shape[row][col]) {
                        const boardX = newX + col;
                        const boardY = newY + row;
                        
                        // Check if out of bounds
                        if (boardX < 0 || boardX >= BOARD_WIDTH || boardY >= BOARD_HEIGHT) {
                            return false;
                        }
                        
                        // Check if collides with placed blocks
                        if (boardY >= 0 && boardY < BOARD_HEIGHT &&
                            boardX >= 0 && boardX < BOARD_WIDTH && 
                            grid[boardY][boardX] !== 0) {
                            return false;
                        }
                    }
                }
            }
            
            return true;
        }
        
        // Lock piece in place
        function lockPiece() {
            const ud = currentPiece.userData;
            
            // Add piece to grid
            for (let row = 0; row < ud.shape.length; row++) {
                for (let col = 0; col < ud.shape[row].length; col++) {
                    if (ud.shape[row][col]) {
                        const boardX = ud.position.x + col;
                        const boardY = ud.position.y + row;
                        
                        if (boardY >= 0 && boardY < BOARD_HEIGHT &&
                            boardX >= 0 && boardX < BOARD_WIDTH) {
                            grid[boardY][boardX] = ud.typeIndex + 1;
                        }
                    }
                }
            }
            
            // Remove current piece
            gameBoard.remove(currentPiece);
            currentPiece = null;
            
            // Check for line clears
            checkLineClears();
        }
        
        // Check for completed lines
        function checkLineClears() {
            let linesCleared = 0;
            let rowsToRemove = [];
            
            // Identify complete rows
            for (let row = 0; row < BOARD_HEIGHT; row++) {
                if (grid[row].every(cell => cell !== 0)) {
                    linesCleared++;
                    rowsToRemove.push(row);
                }
            }
            
            // Process line clears
            if (linesCleared > 0) {
                playSound('clear');
                
                // Score calculation
                const lineScores = [0, 100, 300, 500, 800];
                score += lineScores[linesCleared] * level;
                
                // Update score display
                scoreElement.textContent = score.toString();
                
                // Level up if score threshold reached
                if (score >= level * 2000 && level < LEVEL_SPEEDS.length) {
                    level++;
                    levelElement.textContent = level.toString();
                    
                    // Update game speed
                    clearInterval(gameLoopInterval);
                    gameLoopInterval = setInterval(() => {
                        if (currentPiece) {
                            movePieceDown();
                        }
                    }, LEVEL_SPEEDS[level - 1]);
                }
            }
        }
        
        // Game over handler
        function gameOver() {
            console.log("Game Over");
            gameActive = false;
            clearInterval(gameLoopInterval);
            
            // Play game over sound
            playSound('gameover');
            
            // Show game over screen
            finalScoreElement.textContent = score.toString();
            gameOverScreen.style.display = 'block';
            controlsHint.style.display = 'none';
        }
        
        // Restart game
        function restartGame() {
            console.log("Restarting game");
            resetGameState();
            startGame();
        }
        
        // Touch control variables
        let touchStartX, touchStartY;
        let touchStartTime;
        const TAP_THRESHOLD = 5; // Max movement to consider as tap
        const SWIPE_THRESHOLD = 50; // Min swipe distance
        
        // Handle touch start
        function handleTouchStart(event) {
            if (!gameActive) return;
            touchStartX = event.touches[0].clientX;
            touchStartY = event.touches[0].clientY;
            touchStartTime = Date.now();
        }
        
        // Handle touch move
        function handleTouchMove(event) {
            if (!gameActive) return;
            event.preventDefault();
        }
        
        // Handle touch end
        function handleTouchEnd(event) {
            if (!gameActive || !currentPiece) return;
            
            const touch = event.changedTouches[0];
            const endX = touch.clientX;
            const endY = touch.clientY;
            const deltaX = endX - touchStartX;
            const deltaY = endY - touchStartY;
            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
            const duration = Date.now() - touchStartTime;
            const screenWidth = window.innerWidth;
            
            // Handle tap
            if (distance < TAP_THRESHOLD && duration < 300) {
                const tapX = endX / screenWidth;
                
                // Left side tap (move left)
                if (tapX < 0.4) {
                    if (isValidMove(currentPiece, -1, 0)) {
                        currentPiece.userData.position.x -= 1;
                        updatePiecePosition(currentPiece);
                        playSound('move');
                    }
                }
                // Right side tap (move right)
                else if (tapX > 0.6) {
                    if (isValidMove(currentPiece, 1, 0)) {
                        currentPiece.userData.position.x += 1;
                        updatePiecePosition(currentPiece);
                        playSound('move');
                    }
                }
                // Center tap (rotate)
                else {
                    // Placeholder for rotation function
                    playSound('move');
                }
            }
            // Handle swipe down
            else if (deltaY > SWIPE_THRESHOLD && Math.abs(deltaX) < Math.abs(deltaY)) {
                console.log("Hard drop");
                while (isValidMove(currentPiece, 0, 1)) {
                    currentPiece.userData.position.y += 1;
                    updatePiecePosition(currentPiece);
                }
                lockPiece();
                spawnPiece();
                playSound('drop');
            }
        }
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Main animation loop
        function animate(timestamp, frame) {
            if (frame && hitTestSource) {
                const hitTestResults = frame.getHitTestResults(hitTestSource);
                
                if (hitTestResults.length > 0 && !gameActive) {
                    const hit = hitTestResults[0];
                    const referenceSpace = renderer.xr.getReferenceSpace();
                    const pose = hit.getPose(referenceSpace);
                    
                    // Update placement grid position
                    placementGrid.matrix.fromArray(pose.transform.matrix);
                    placementGrid.visible = true;
                }
            }
            
            renderer.render(scene, camera);
        }
        
        // Place the game board in AR space
        function placeGameBoard() {
            if (gameActive) return;
            
            // Position game board at placement grid
            gameBoard.matrix.copy(placementGrid.matrix);
            
            // Center the board vertically
            gameBoard.position.y += BOARD_SIZE / 2;
            
            // Add game board to scene
            scene.add(gameBoard);
            
            // Hide placement grid
            placementGrid.visible = false;
            placementHint.style.display = 'none';
            
            // Start the game
            startGame();
        }
        
        // Start the game initialization
        init();
    </script>
</body>
</html>
