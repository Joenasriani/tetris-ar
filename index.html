<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="xr-spatial-tracking" content="true">
    <title>AR Tetris Pro</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body, html {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #000;
            font-family: system-ui, sans-serif;
            touch-action: none;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui {
            position: fixed;
            top: 15px;
            left: 15px;
            z-index: 1000;
            pointer-events: none;
        }

        .ui-panel {
            background: rgba(30, 30, 45, 0.9);
            padding: 10px 15px;
            border-radius: 10px;
            margin-bottom: 10px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.1);
        }

        #next-piece {
            position: fixed;
            top: 15px;
            right: 15px;
            width: 70px;
            height: 70px;
            background: rgba(30, 30, 45, 0.9);
            border-radius: 10px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.1);
        }

        #ar-button {
            position: fixed;
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, #6a11cb, #2575fc);
            color: white;
            border: none;
            padding: 14px 35px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 6px 20px rgba(37, 117, 252, 0.4);
            z-index: 1001;
            transition: transform 0.2s;
        }

        #ar-button:active {
            transform: translateX(-50%) scale(0.95);
        }

        #placement-hint {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            padding: 12px 20px;
            border-radius: 8px;
            text-align: center;
            max-width: 80%;
            display: none;
        }

        #game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
        }

        .loader {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #6a11cb;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="ui">
        <div class="ui-panel">
            <div>SCORE: <span id="score">0</span></div>
            <div>LEVEL: <span id="level">1</span></div>
        </div>
    </div>
    
    <div id="next-piece"></div>
    <button id="ar-button">START AR</button>
    <div id="placement-hint">Find a flat surface and tap to place board</div>
    <div id="game-over">
        <h2>GAME OVER</h2>
        <p>Score: <span id="final-score">0</span></p>
        <button onclick="location.reload()">Play Again</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';

        // Game Constants
        const BOARD_SIZE = 2.0; // 2 meters real-world
        const BOARD_WIDTH = 10;
        const BOARD_HEIGHT = 20;
        const BLOCK_SIZE = BOARD_SIZE / BOARD_WIDTH;
        const SHAPES = [
            [[1,1,1,1]], [[1,1],[1,1]], [[0,1,0],[1,1,1]],
            [[0,1,1],[1,1,0]], [[1,1,0],[0,1,1]],
            [[1,0],[1,0],[1,1]], [[0,1],[0,1],[1,1]]
        ];
        const COLORS = [0x00F0F0, 0xF0F000, 0xA000F0, 0x00F000, 0xF00000, 0x0000F0, 0xF0A000];

        // Game State
        let renderer, scene, camera, gameBoard;
        let currentPiece, nextPieceType;
        let score = 0, level = 1, gameActive = false;
        let hitTestSource = null;
        const grid = Array(BOARD_HEIGHT).fill().map(() => Array(BOARD_WIDTH).fill(0));

        // Initialize AR
        async function init() {
            // Scene Setup
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 20);
            
            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(0.5, 1, 0.5);
            scene.add(directionalLight);

            // AR Setup
            const arButton = ARButton.createButton(renderer, {
                requiredFeatures: ['hit-test'],
                optionalFeatures: ['dom-overlay']
            });
            arButton.id = 'default-ar-button';
            arButton.style.display = 'none';
            document.body.appendChild(arButton);

            document.getElementById('ar-button').addEventListener('click', () => {
                arButton.click();
                document.getElementById('placement-hint').style.display = 'block';
            });

            // Game Board
            gameBoard = new THREE.Group();
            
            // Placement Grid
            const gridGeometry = new THREE.PlaneGeometry(BOARD_SIZE, BOARD_SIZE);
            const gridMaterial = new THREE.MeshBasicMaterial({
                color: 0x0099ff,
                wireframe: true,
                transparent: true,
                opacity: 0.5
            });
            const placementGrid = new THREE.Mesh(gridGeometry, gridMaterial);
            placementGrid.rotation.x = -Math.PI/2;
            placementGrid.visible = false;
            scene.add(placementGrid);

            // XR Events
            renderer.xr.addEventListener('sessionstart', async (session) => {
                const referenceSpace = await session.requestReferenceSpace('viewer');
                hitTestSource = await session.requestHitTestSource({ space: referenceSpace });
                session.addEventListener('select', placeBoard);
            });

            renderer.setAnimationLoop((timestamp, frame) => {
                if(frame && hitTestSource) {
                    const hitTestResults = frame.getHitTestResults(hitTestSource);
                    if(hitTestResults.length > 0) {
                        const pose = hitTestResults[0].getPose(renderer.xr.getReferenceSpace());
                        placementGrid.matrix.fromArray(pose.transform.matrix);
                        placementGrid.visible = true;
                    }
                }
                renderer.render(scene, camera);
            });
        }

        // Game Functions
        function placeBoard() {
            if(!gameActive) {
                gameActive = true;
                spawnPiece();
                document.getElementById('placement-hint').style.display = 'none';
            }
        }

        function spawnPiece() {
            const type = Math.floor(Math.random() * SHAPES.length);
            const shape = SHAPES[type];
            const color = COLORS[type];
            
            const piece = new THREE.Group();
            piece.position.set(0, BOARD_SIZE/2, 0);
            
            const geometry = new THREE.BoxGeometry(BLOCK_SIZE*0.9, BLOCK_SIZE*0.9, BLOCK_SIZE*0.9);
            const material = new THREE.MeshPhongMaterial({ color, emissive: color, emissiveIntensity: 0.1 });
            
            for(let y = 0; y < shape.length; y++) {
                for(let x = 0; x < shape[y].length; x++) {
                    if(shape[y][x]) {
                        const block = new THREE.Mesh(geometry, material);
                        block.position.set(
                            x * BLOCK_SIZE - (shape[y].length * BLOCK_SIZE)/2,
                            -y * BLOCK_SIZE,
                            0
                        );
                        piece.add(block);
                    }
                }
            }
            
            gameBoard.add(piece);
            currentPiece = piece;
        }

        // Touch Controls
        let touchStartX = 0;
        document.addEventListener('touchstart', e => {
            touchStartX = e.touches[0].clientX;
        });

        document.addEventListener('touchend', e => {
            if(!gameActive) return;
            
            const touchEndX = e.changedTouches[0].clientX;
            const deltaX = touchEndX - touchStartX;
            
            if(Math.abs(deltaX) > 30) {
                currentPiece.position.x += Math.sign(deltaX) * BLOCK_SIZE;
            } else {
                currentPiece.rotation.z += Math.PI/2;
            }
        });

        // Initialize Game
        init();
    </script>
</body>
</html>
