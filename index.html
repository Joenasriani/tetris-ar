<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>AR Tetris</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-user-select: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            overflow: hidden;
            position: fixed;
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        #startOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            transition: opacity 0.3s;
        }
        
        #startOverlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        #startOverlay h1 {
            color: white;
            font-size: 48px;
            margin-bottom: 20px;
            text-shadow: 0 0 20px rgba(102, 126, 234, 0.8);
        }
        
        #statusText {
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 30px;
            text-align: center;
            padding: 0 20px;
            line-height: 1.6;
        }
        
        #startBtn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 20px 50px;
            font-size: 24px;
            border-radius: 50px;
            cursor: pointer;
            box-shadow: 0 10px 30px rgba(102, 126, 234, 0.5);
            transition: transform 0.2s, box-shadow 0.2s;
            font-weight: bold;
        }
        
        #startBtn:active {
            transform: scale(0.95);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.5);
        }
        
        #startBtn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        #instructions {
            position: fixed;
            top: 30%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            font-size: 22px;
            z-index: 100;
            display: none;
            max-width: 90%;
            animation: instructionPulse 3s infinite;
            line-height: 1.6;
            border: 3px solid rgba(102, 126, 234, 0.8);
        }
        
        @keyframes instructionPulse {
            0%, 100% { 
                transform: translateX(-50%) scale(1);
                border-color: rgba(102, 126, 234, 0.8);
            }
            50% { 
                transform: translateX(-50%) scale(1.05);
                border-color: rgba(255, 255, 255, 0.9);
            }
        }
        
        #floorDetected {
            position: fixed;
            bottom: 30%;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 200, 0, 0.9);
            color: white;
            padding: 20px 30px;
            border-radius: 15px;
            font-size: 20px;
            font-weight: bold;
            z-index: 150;
            display: none;
            animation: bounce 0.8s infinite;
        }
        
        @keyframes bounce {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(-10px); }
        }
        
        #ui {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 30px;
            border-radius: 15px;
            color: white;
            display: none;
            z-index: 10;
            backdrop-filter: blur(10px);
        }
        
        .stat {
            display: inline-block;
            margin: 0 15px;
            font-size: 18px;
        }
        
        .stat-label {
            opacity: 0.7;
            margin-right: 5px;
        }
        
        .stat-value {
            font-weight: bold;
            font-size: 22px;
        }
        
        #touchZones {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            pointer-events: none;
            z-index: 5;
        }
        
        .touch-indicator {
            position: absolute;
            width: 50%;
            height: 100%;
            background: rgba(255, 255, 255, 0);
            transition: background 0.2s;
            pointer-events: none;
        }
        
        .touch-indicator.active {
            background: rgba(255, 255, 255, 0.1);
        }
        
        #leftZone {
            left: 0;
            border-right: 2px solid rgba(255, 255, 255, 0.1);
        }
        
        #rightZone {
            right: 0;
            border-left: 2px solid rgba(255, 255, 255, 0.1);
        }
        
        #controlsHelp {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px 30px;
            border-radius: 15px;
            text-align: center;
            z-index: 20;
            opacity: 0;
            transition: opacity 0.3s;
            max-width: 90%;
        }
        
        #controlsHelp.show {
            opacity: 1;
        }
        
        #controlsHelp div {
            margin: 8px 0;
            font-size: 16px;
        }
        
        #rotateIndicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(102, 126, 234, 0.9);
            color: white;
            padding: 20px 40px;
            border-radius: 15px;
            font-size: 24px;
            font-weight: bold;
            z-index: 30;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
        }
        
        #rotateIndicator.active {
            opacity: 1;
        }
        
        #reticle {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            z-index: 15;
            display: none;
            pointer-events: none;
        }
        
        #reticle::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 12px;
            height: 12px;
            background: rgba(102, 126, 234, 0.9);
            border-radius: 50%;
            animation: reticlePulse 1.5s infinite;
        }
        
        @keyframes reticlePulse {
            0%, 100% { 
                transform: translate(-50%, -50%) scale(1); 
                opacity: 1; 
            }
            50% { 
                transform: translate(-50%, -50%) scale(1.8); 
                opacity: 0.3; 
            }
        }
        
        #reticle.floor-detected {
            border-color: #00ff00;
            animation: reticleFound 1s infinite;
        }
        
        @keyframes reticleFound {
            0%, 100% { 
                transform: translate(-50%, -50%) scale(1); 
                border-color: #00ff00;
            }
            50% { 
                transform: translate(-50%, -50%) scale(1.2); 
                border-color: #ffffff;
            }
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="startOverlay">
        <h1>🎮 AR TETRIS</h1>
        <div id="statusText">
            <strong>Ready to play in Augmented Reality!</strong><br>
            Point your camera at a flat surface
        </div>
        <button id="startBtn">START AR</button>
    </div>
    
    <div id="instructions">
        🎯 <strong>Point camera at the floor</strong><br>
        👆 <strong>TAP when you see the green circle!</strong>
    </div>
    
    <div id="floorDetected">
        ✅ <strong>FLOOR FOUND - TAP TO PLACE!</strong>
    </div>
    
    <div id="reticle"></div>
    
    <div id="ui">
        <div class="stat">
            <span class="stat-label">SCORE:</span>
            <span class="stat-value" id="score">0</span>
        </div>
        <div class="stat">
            <span class="stat-label">LEVEL:</span>
            <span class="stat-value" id="level">1</span>
        </div>
        <div class="stat">
            <span class="stat-label">LINES:</span>
            <span class="stat-value" id="lines">0</span>
        </div>
    </div>
    
    <div id="touchZones">
        <div class="touch-indicator" id="leftZone"></div>
        <div class="touch-indicator" id="rightZone"></div>
    </div>
    
    <div id="controlsHelp">
        <div>👆 <strong>TAP LEFT</strong> = Move Left</div>
        <div>👆 <strong>TAP RIGHT</strong> = Move Right</div>
        <div>👆👆 <strong>DOUBLE TAP</strong> = Rotate</div>
        <div>👇 <strong>SWIPE DOWN</strong> = Drop Faster</div>
    </div>
    
    <div id="rotateIndicator">🔄 ROTATE</div>

    <script type="module">
        class ARTetris {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.gl = null;
                
                this.xrSession = null;
                this.xrRefSpace = null;
                this.hitTestSource = null;
                this.gamePlaced = false;
                this.gameAnchor = null;
                this.floorFound = false;
                
                this.board = Array(20).fill().map(() => Array(10).fill(0));
                this.currentPiece = null;
                this.currentX = 0;
                this.currentY = 0;
                this.score = 0;
                this.level = 1;
                this.lines = 0;
                this.dropTime = 1000;
                this.lastTime = 0;
                this.gameRunning = false;
                
                this.lastTapTime = 0;
                this.doubleTapDelay = 400;
                this.touchStartY = 0;
                this.touchStartX = 0;
                this.swipeThreshold = 30;
                this.tapThreshold = 10;
                this.touchMoved = false;
                
                this.pieces = {
                    I: { shape: [[1,1,1,1]], color: [0, 1, 1, 1] },
                    O: { shape: [[1,1],[1,1]], color: [1, 1, 0, 1] },
                    T: { shape: [[0,1,0],[1,1,1]], color: [0.5, 0, 0.5, 1] },
                    S: { shape: [[0,1,1],[1,1,0]], color: [0, 1, 0, 1] },
                    Z: { shape: [[1,1,0],[0,1,1]], color: [1, 0, 0, 1] },
                    J: { shape: [[1,0,0],[1,1,1]], color: [0, 0, 1, 1] },
                    L: { shape: [[0,0,1],[1,1,1]], color: [1, 0.65, 0, 1] }
                };
                
                this.init();
            }
            
            init() {
                this.setupCanvas();
                this.setupEventListeners();
                this.preventZoom();
            }
            
            initWebGL() {
                if (this.gl) return;
                
                this.gl = this.canvas.getContext('webgl', { 
                    alpha: true,
                    antialias: true 
                });
                
                this.setupWebGL();
            }
            
            preventZoom() {
                document.addEventListener('touchmove', (e) => {
                    if (e.touches.length > 1) {
                        e.preventDefault();
                    }
                }, { passive: false });
                
                document.addEventListener('touchend', (e) => {
                    const now = Date.now();
                    const timeSince = now - this.lastTouchEnd;
                    if (timeSince < 300 && timeSince > 0) {
                        e.preventDefault();
                    }
                    this.lastTouchEnd = now;
                }, false);
                
                document.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                });
            }
            
            setupCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }
            
            setupWebGL() {
                const gl = this.gl;
                
                const vertexShaderSource = `
                    attribute vec3 position;
                    attribute vec3 normal;
                    
                    uniform mat4 projectionMatrix;
                    uniform mat4 viewMatrix;
                    uniform mat4 modelMatrix;
                    uniform mat4 normalMatrix;
                    
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    
                    void main() {
                        vNormal = normalize((normalMatrix * vec4(normal, 0.0)).xyz);
                        vec4 worldPosition = modelMatrix * vec4(position, 1.0);
                        vPosition = worldPosition.xyz;
                        gl_Position = projectionMatrix * viewMatrix * worldPosition;
                    }
                `;
                
                const fragmentShaderSource = `
                    precision mediump float;
                    
                    uniform vec4 color;
                    uniform vec3 lightPosition;
                    uniform vec3 viewPosition;
                    
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    
                    void main() {
                        vec3 ambient = 0.3 * color.rgb;
                        
                        vec3 lightDir = normalize(lightPosition - vPosition);
                        float diff = max(dot(vNormal, lightDir), 0.0);
                        vec3 diffuse = 0.6 * diff * color.rgb;
                        
                        vec3 viewDir = normalize(viewPosition - vPosition);
                        vec3 reflectDir = reflect(-lightDir, vNormal);
                        float spec = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);
                        vec3 specular = 0.3 * spec * vec3(1.0, 1.0, 1.0);
                        
                        vec3 result = ambient + diffuse + specular;
                        gl_FragColor = vec4(result, color.a);
                    }
                `;
                
                const vertexShader = gl.createShader(gl.VERTEX_SHADER);
                gl.shaderSource(vertexShader, vertexShaderSource);
                gl.compileShader(vertexShader);
                
                const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
                gl.shaderSource(fragmentShader, fragmentShaderSource);
                gl.compileShader(fragmentShader);
                
                this.program = gl.createProgram();
                gl.attachShader(this.program, vertexShader);
                gl.attachShader(this.program, fragmentShader);
                gl.linkProgram(this.program);
                gl.useProgram(this.program);
                
                this.positionLocation = gl.getAttribLocation(this.program, 'position');
                this.normalLocation = gl.getAttribLocation(this.program, 'normal');
                this.projectionMatrixLocation = gl.getUniformLocation(this.program, 'projectionMatrix');
                this.viewMatrixLocation = gl.getUniformLocation(this.program, 'viewMatrix');
                this.modelMatrixLocation = gl.getUniformLocation(this.program, 'modelMatrix');
                this.normalMatrixLocation = gl.getUniformLocation(this.program, 'normalMatrix');
                this.colorLocation = gl.getUniformLocation(this.program, 'color');
                this.lightPositionLocation = gl.getUniformLocation(this.program, 'lightPosition');
                this.viewPositionLocation = gl.getUniformLocation(this.program, 'viewPosition');
                
                this.createCubeBuffer();
                
                gl.enable(gl.DEPTH_TEST);
            }
            
            createCubeBuffer() {
                const gl = this.gl;
                
                const vertices = new Float32Array([
                    -0.5, -0.5,  0.5,   0, 0, 1,
                     0.5, -0.5,  0.5,   0, 0, 1,
                     0.5,  0.5,  0.5,   0, 0, 1,
                    -0.5,  0.5,  0.5,   0, 0, 1,
                    
                    -0.5, -0.5, -0.5,   0, 0, -1,
                    -0.5,  0.5, -0.5,   0, 0, -1,
                     0.5,  0.5, -0.5,   0, 0, -1,
                     0.5, -0.5, -0.5,   0, 0, -1,
                    
                    -0.5,  0.5, -0.5,   0, 1, 0,
                    -0.5,  0.5,  0.5,   0, 1, 0,
                     0.5,  0.5,  0.5,   0, 1, 0,
                     0.5,  0.5, -0.5,   0, 1, 0,
                    
                    -0.5, -0.5, -0.5,   0, -1, 0,
                     0.5, -0.5, -0.5,   0, -1, 0,
                     0.5, -0.5,  0.5,   0, -1, 0,
                    -0.5, -0.5,  0.5,   0, -1, 0,
                    
                     0.5, -0.5, -0.5,   1, 0, 0,
                     0.5,  0.5, -0.5,   1, 0, 0,
                     0.5,  0.5,  0.5,   1, 0, 0,
                     0.5, -0.5,  0.5,   1, 0, 0,
                    
                    -0.5, -0.5, -0.5,   -1, 0, 0,
                    -0.5, -0.5,  0.5,   -1, 0, 0,
                    -0.5,  0.5,  0.5,   -1, 0, 0,
                    -0.5,  0.5, -0.5,   -1, 0, 0
                ]);
                
                const indices = new Uint16Array([
                    0,  1,  2,  0,  2,  3,
                    4,  5,  6,  4,  6,  7,
                    8,  9, 10,  8, 10, 11,
                    12, 13, 14, 12, 14, 15,
                    16, 17, 18, 16, 18, 19,
                    20, 21, 22, 20, 22, 23
                ]);
                
                this.vertexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
                
                this.indexBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);
                
                this.indexCount = indices.length;
            }
            
            setupEventListeners() {
                document.getElementById('startBtn').addEventListener('click', () => {
                    this.startAR();
                });
                
                this.canvas.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: false });
                this.canvas.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });
                this.canvas.addEventListener('touchend', (e) => this.handleTouchEnd(e), { passive: false });
            }
            
            handleTouchStart(e) {
                e.preventDefault();
                
                // If waiting to place game and floor is detected
                if (this.xrSession && !this.gamePlaced && this.floorFound) {
                    this.placeGame = true;
                    return;
                }
                
                if (!this.gameRunning) return;
                
                const touch = e.touches[0];
                this.touchStartY = touch.clientY;
                this.touchStartX = touch.clientX;
                this.touchStartTime = Date.now();
                this.touchMoved = false;
            }
            
            handleTouchMove(e) {
                e.preventDefault();
                
                if (!this.gameRunning) return;
                
                const touch = e.touches[0];
                const deltaY = Math.abs(touch.clientY - this.touchStartY);
                const deltaX = Math.abs(touch.clientX - this.touchStartX);
                
                if (deltaY > this.tapThreshold || deltaX > this.tapThreshold) {
                    this.touchMoved = true;
                }
                
                const actualDeltaY = touch.clientY - this.touchStartY;
                if (actualDeltaY > this.swipeThreshold && !this.touchMoved) {
                    this.moveDown();
                    this.touchStartY = touch.clientY;
                    this.touchMoved = true;
                }
            }
            
            handleTouchEnd(e) {
                e.preventDefault();
                
                if (!this.gameRunning || !this.gamePlaced) return;
                
                const touch = e.changedTouches[0];
                const touchDuration = Date.now() - this.touchStartTime;
                
                if (this.touchMoved || touchDuration > 600) return;
                
                const x = touch.clientX;
                const screenWidth = window.innerWidth;
                
                const currentTime = Date.now();
                const timeSinceLastTap = currentTime - this.lastTapTime;
                
                if (timeSinceLastTap < this.doubleTapDelay && timeSinceLastTap > 50) {
                    this.rotate();
                    this.showRotateIndicator();
                    this.lastTapTime = 0;
                } else {
                    if (x < screenWidth * 0.5) {
                        this.moveLeft();
                        this.showLeftIndicator();
                    } else {
                        this.moveRight();
                        this.showRightIndicator();
                    }
                    
                    this.lastTapTime = currentTime;
                }
            }
            
            showLeftIndicator() {
                const indicator = document.getElementById('leftZone');
                indicator.classList.add('active');
                setTimeout(() => indicator.classList.remove('active'), 200);
            }
            
            showRightIndicator() {
                const indicator = document.getElementById('rightZone');
                indicator.classList.add('active');
                setTimeout(() => indicator.classList.remove('active'), 200);
            }
            
            showRotateIndicator() {
                const indicator = document.getElementById('rotateIndicator');
                indicator.classList.add('active');
                setTimeout(() => indicator.classList.remove('active'), 300);
            }
            
            async startAR() {
                const statusText = document.getElementById('statusText');
                const startBtn = document.getElementById('startBtn');
                
                try {
                    this.initWebGL();
                    
                    if (!navigator.xr) {
                        throw new Error('WebXR not supported. Please use Chrome on Android.');
                    }
                    
                    statusText.textContent = '🚀 Starting AR experience...';
                    startBtn.disabled = true;
                    
                    // Request AR session with hit-test
                    this.xrSession = await navigator.xr.requestSession('immersive-ar', {
                        requiredFeatures: ['hit-test']
                    });
                    
                    await this.onSessionStarted();
                    
                } catch (error) {
                    console.error('AR Error:', error);
                    startBtn.disabled = false;
                    statusText.textContent = `❌ ${error.message}`;
                    
                    setTimeout(() => {
                        statusText.innerHTML = `
                            💡 <strong>Troubleshooting:</strong><br>
                            • Update Chrome to latest version<br>
                            • Install/Update Google ARCore<br>
                            • Allow camera permission<br>
                            • Try restarting the browser
                        `;
                    }, 3000);
                }
            }
            
            async onSessionStarted() {
                this.xrSession.addEventListener('end', () => this.onSessionEnded());
                
                await this.gl.makeXRCompatible();
                
                this.xrSession.updateRenderState({
                    baseLayer: new XRWebGLLayer(this.xrSession, this.gl)
                });
                
                // Use local-floor for better floor detection
                this.xrRefSpace = await this.xrSession.requestReferenceSpace('local-floor');
                
                // Request hit test source with viewer space for better tracking
                const viewerSpace = await this.xrSession.requestReferenceSpace('viewer');
                this.hitTestSource = await this.xrSession.requestHitTestSource({ space: viewerSpace });
                
                document.getElementById('startOverlay').classList.add('hidden');
                document.getElementById('instructions').style.display = 'block';
                document.getElementById('reticle').style.display = 'block';
                
                this.xrSession.requestAnimationFrame((time, frame) => this.onXRFrame(time, frame));
            }
            
            onSessionEnded() {
                this.xrSession = null;
                this.hitTestSource = null;
                this.gamePlaced = false;
                this.gameRunning = false;
                this.floorFound = false;
                document.getElementById('startOverlay').classList.remove('hidden');
                document.getElementById('instructions').style.display = 'none';
                document.getElementById('reticle').style.display = 'none';
                document.getElementById('floorDetected').style.display = 'none';
                document.getElementById('ui').style.display = 'none';
                document.getElementById('touchZones').style.display = 'none';
                document.getElementById('controlsHelp').classList.remove('show');
            }
            
            onXRFrame(time, frame) {
                const session = frame.session;
                session.requestAnimationFrame((time, frame) => this.onXRFrame(time, frame));
                
                const gl = this.gl;
                const pose = frame.getViewerPose(this.xrRefSpace);
                
                if (pose) {
                    const layer = session.renderState.baseLayer;
                    gl.bindFramebuffer(gl.FRAMEBUFFER, layer.framebuffer);
                    
                    gl.clearColor(0, 0, 0, 0);
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                    
                    // Check for floor detection every frame
                    if (this.hitTestSource && !this.gamePlaced) {
                        const hitTestResults = frame.getHitTestResults(this.hitTestSource);
                        
                        if (hitTestResults.length > 0) {
                            // Floor detected!
                            if (!this.floorFound) {
                                this.floorFound = true;
                                document.getElementById('reticle').classList.add('floor-detected');
                                document.getElementById('floorDetected').style.display = 'block';
                            }
                            
                            // If user tapped, place the game
                            if (this.placeGame) {
                                const hit = hitTestResults[0];
                                const hitPose = hit.getPose(this.xrRefSpace);
                                
                                if (hitPose) {
                                    this.gameAnchor = hitPose.transform.matrix;
                                    this.gamePlaced = true;
                                    this.placeGame = false;
                                    
                                    document.getElementById('instructions').style.display = 'none';
                                    document.getElementById('reticle').style.display = 'none';
                                    document.getElementById('floorDetected').style.display = 'none';
                                    document.getElementById('ui').style.display = 'block';
                                    document.getElementById('touchZones').style.display = 'block';
                                    
                                    const controlsHelp = document.getElementById('controlsHelp');
                                    controlsHelp.classList.add('show');
                                    setTimeout(() => {
                                        controlsHelp.classList.remove('show');
                                    }, 7000);
                                    
                                    this.startGame();
                                }
                            }
                        } else {
                            // No floor detected
                            if (this.floorFound) {
                                this.floorFound = false;
                                document.getElementById('reticle').classList.remove('floor-detected');
                                document.getElementById('floorDetected').style.display = 'none';
                            }
                        }
                    }
                    
                    for (const view of pose.views) {
                        const viewport = layer.getViewport(view);
                        gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
                        
                        if (this.gamePlaced && this.gameAnchor) {
                            this.renderGame(view.projectionMatrix, view.transform.inverse.matrix, pose.transform.position);
                        }
                    }
                }
                
                if (this.gameRunning) {
                    const currentTime = Date.now();
                    if (currentTime - this.lastTime > this.dropTime) {
                        this.moveDown();
                        this.lastTime = currentTime;
                    }
                }
            }
            
            renderGame(projectionMatrix, viewMatrix, viewPosition) {
                const gl = this.gl;
                gl.useProgram(this.program);
                
                gl.uniformMatrix4fv(this.projectionMatrixLocation, false, projectionMatrix);
                gl.uniformMatrix4fv(this.viewMatrixLocation, false, viewMatrix);
                
                gl.uniform3fv(this.lightPositionLocation, [0, 0.5, 0.5]);
                gl.uniform3fv(this.viewPositionLocation, viewPosition ? 
                    [viewPosition.x, viewPosition.y, viewPosition.z] : [0, 0, 0]);
                
                gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
                
                const stride = 6 * 4;
                gl.enableVertexAttribArray(this.positionLocation);
                gl.vertexAttribPointer(this.positionLocation, 3, gl.FLOAT, false, stride, 0);
                gl.enableVertexAttribArray(this.normalLocation);
                gl.vertexAttribPointer(this.normalLocation, 3, gl.FLOAT, false, stride, 3 * 4);
                
                const blockSize = 0.05;
                
                // Game board
                this.drawCube(
                    [0, 0, 0],
                    [blockSize * 10, blockSize * 20, blockSize * 0.5],
                    [0.15, 0.15, 0.15, 0.5]
                );
                
                // Placed blocks
                for (let y = 0; y < this.board.length; y++) {
                    for (let x = 0; x < this.board[y].length; x++) {
                        if (this.board[y][x]) {
                            this.drawCube(
                                [(x - 4.5) * blockSize, (19 - y) * blockSize - 0.475, blockSize * 0.25],
                                [blockSize * 0.9, blockSize * 0.9, blockSize * 0.9],
                                this.board[y][x]
                            );
                        }
                    }
                }
                
                // Current piece
                if (this.currentPiece) {
                    const shape = this.currentPiece.shape;
                    for (let y = 0; y < shape.length; y++) {
                        for (let x = 0; x < shape[y].length; x++) {
                            if (shape[y][x]) {
                                this.drawCube(
                                    [(this.currentX + x - 4.5) * blockSize, (19 - (this.currentY + y)) * blockSize - 0.475, blockSize * 0.25],
                                    [blockSize * 0.9, blockSize * 0.9, blockSize * 0.9],
                                    this.currentPiece.color
                                );
                            }
                        }
                    }
                }
            }
            
            drawCube(position, scale, color) {
                const gl = this.gl;
                
                const modelMatrix = new Float32Array(16);
                this.mat4identity(modelMatrix);
                this.mat4multiply(modelMatrix, this.gameAnchor, modelMatrix);
                
                const tiltMatrix = new Float32Array(16);
                this.mat4identity(tiltMatrix);
                this.mat4rotateX(tiltMatrix, -0.436);
                this.mat4multiply(modelMatrix, modelMatrix, tiltMatrix);
                
                this.mat4translate(modelMatrix, position[0], position[1], position[2]);
                this.mat4scale(modelMatrix, scale[0], scale[1], scale[2]);
                
                const normalMatrix = new Float32Array(16);
                this.mat4copy(normalMatrix, modelMatrix);
                this.mat4invert(normalMatrix);
                this.mat4transpose(normalMatrix);
                
                gl.uniformMatrix4fv(this.modelMatrixLocation, false, modelMatrix);
                gl.uniformMatrix4fv(this.normalMatrixLocation, false, normalMatrix);
                gl.uniform4fv(this.colorLocation, color);
                
                gl.drawElements(gl.TRIANGLES, this.indexCount, gl.UNSIGNED_SHORT, 0);
            }
            
            // Matrix math functions (keeping them the same)
            mat4identity(out) {
                out[0] = 1; out[1] = 0; out[2] = 0; out[3] = 0;
                out[4] = 0; out[5] = 1; out[6] = 0; out[7] = 0;
                out[8] = 0; out[9] = 0; out[10] = 1; out[11] = 0;
                out[12] = 0; out[13] = 0; out[14] = 0; out[15] = 1;
            }
            
            mat4multiply(out, a, b) {
                const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
                const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
                const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
                const a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
                
                let b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
                out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
                out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
                out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
                out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
                
                b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
                out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
                out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
                out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
                out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
                
                b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
                out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
                out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
                out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
                out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
                
                b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
                out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
                out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
                out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
                out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
            }
            
            mat4translate(out, x, y, z) {
                out[12] = out[0] * x + out[4] * y + out[8] * z + out[12];
                out[13] = out[1] * x + out[5] * y + out[9] * z + out[13];
                out[14] = out[2] * x + out[6] * y + out[10] * z + out[14];
                out[15] = out[3] * x + out[7] * y + out[11] * z + out[15];
            }
            
            mat4scale(out, x, y, z) {
                out[0] *= x; out[1] *= x; out[2] *= x; out[3] *= x;
                out[4] *= y; out[5] *= y; out[6] *= y; out[7] *= y;
                out[8] *= z; out[9] *= z; out[10] *= z; out[11] *= z;
            }
            
            mat4rotateX(out, angle) {
                const c = Math.cos(angle);
                const s = Math.sin(angle);
                const temp = new Float32Array(16);
                this.mat4identity(temp);
                temp[5] = c;
                temp[6] = s;
                temp[9] = -s;
                temp[10] = c;
                this.mat4multiply(out, out, temp);
            }
            
            mat4invert(out) {
                const a00 = out[0], a01 = out[1], a02 = out[2], a03 = out[3];
                const a10 = out[4], a11 = out[5], a12 = out[6], a13 = out[7];
                const a20 = out[8], a21 = out[9], a22 = out[10], a23 = out[11];
                const a30 = out[12], a31 = out[13], a32 = out[14], a33 = out[15];
                
                const b00 = a00 * a11 - a01 * a10;
                const b01 = a00 * a12 - a02 * a10;
                const b02 = a00 * a13 - a03 * a10;
                const b03 = a01 * a12 - a02 * a11;
                const b04 = a01 * a13 - a03 * a11;
                const b05 = a02 * a13 - a03 * a12;
                const b06 = a20 * a31 - a21 * a30;
                const b07 = a20 * a32 - a22 * a30;
                const b08 = a20 * a33 - a23 * a30;
                const b09 = a21 * a32 - a22 * a31;
                const b10 = a21 * a33 - a23 * a31;
                const b11 = a22 * a33 - a23 * a32;
                
                let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
                if (!det) return;
                det = 1.0 / det;
                
                out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
                out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
                out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
                out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
                out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
                out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
                out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
                out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
                out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
                out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
                out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
                out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
                out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
                out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
                out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
                out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;
            }
            
            mat4transpose(out) {
                const a01 = out[1], a02 = out[2], a03 = out[3];
                const a12 = out[6], a13 = out[7];
                const a23 = out[11];
                
                out[1] = out[4];
                out[2] = out[8];
                out[3] = out[12];
                out[4] = a01;
                out[6] = out[9];
                out[7] = out[13];
                out[8] = a02;
                out[9] = a12;
                out[11] = out[14];
                out[12] = a03;
                out[13] = a13;
                out[14] = a23;
            }
            
            mat4copy(out, a) {
                out[0] = a[0]; out[1] = a[1]; out[2] = a[2]; out[3] = a[3];
                out[4] = a[4]; out[5] = a[5]; out[6] = a[6]; out[7] = a[7];
                out[8] = a[8]; out[9] = a[9]; out[10] = a[10]; out[11] = a[11];
                out[12] = a[12]; out[13] = a[13]; out[14] = a[14]; out[15] = a[15];
            }
            
            startGame() {
                this.gameRunning = true;
                this.spawnPiece();
            }
            
            spawnPiece() {
                const pieceTypes = Object.keys(this.pieces);
                const randomType = pieceTypes[Math.floor(Math.random() * pieceTypes.length)];
                const pieceData = this.pieces[randomType];
                
                this.currentPiece = {
                    type: randomType,
                    shape: pieceData.shape,
                    color: pieceData.color
                };
                
                this.currentX = Math.floor(10 / 2) - Math.floor(this.currentPiece.shape[0].length / 2);
                this.currentY = 0;
                
                if (this.collision()) {
                    this.gameOver();
                }
            }
            
            collision() {
                const shape = this.currentPiece.shape;
                for (let y = 0; y < shape.length; y++) {
                    for (let x = 0; x < shape[y].length; x++) {
                        if (shape[y][x]) {
                            const newX = this.currentX + x;
                            const newY = this.currentY + y;
                            if (newX < 0 || newX >= 10 || newY >= 20) return true;
                            if (newY >= 0 && this.board[newY][newX]) return true;
                        }
                    }
                }
                return false;
            }
            
            placePiece() {
                const shape = this.currentPiece.shape;
                for (let y = 0; y < shape.length; y++) {
                    for (let x = 0; x < shape[y].length; x
                        if (shape[y][x]) {
                            const boardY = this.currentY + y;
                            const boardX = this.currentX + x;
                            if (boardY >= 0) {
                                this.board[boardY][boardX] = this.currentPiece.color;
                            }
                        }
                    }
                }
                
                this.clearLines();
                this.spawnPiece();
            }
            
            clearLines() {
                let linesCleared = 0;
                for (let y = this.board.length - 1; y >= 0; y--) {
                    if (this.board[y].every(cell => cell !== 0)) {
                        this.board.splice(y, 1);
                        this.board.unshift(Array(10).fill(0));
                        linesCleared++;
                        y++; // Check the same line again
                    }
                }
                
                if (linesCleared > 0) {
                    this.lines += linesCleared;
                    this.score += linesCleared * 100 * this.level;
                    this.level = Math.floor(this.lines / 10) + 1;
                    this.dropTime = Math.max(100, 1000 - (this.level - 1) * 100);
                    this.updateUI();
                }
            }
            
            moveLeft() {
                if (!this.currentPiece) return;
                this.currentX--;
                if (this.collision()) {
                    this.currentX++;
                }
            }
            
            moveRight() {
                if (!this.currentPiece) return;
                this.currentX++;
                if (this.collision()) {
                    this.currentX--;
                }
            }
            
            moveDown() {
                if (!this.currentPiece) return;
                this.currentY++;
                if (this.collision()) {
                    this.currentY--;
                    this.placePiece();
                }
            }
            
            rotate() {
                if (!this.currentPiece) return;
                const originalShape = this.currentPiece.shape;
                const rotated = this.rotateMatrix(originalShape);
                this.currentPiece.shape = rotated;
                
                if (this.collision()) {
                    // Try wall kicks
                    const originalX = this.currentX;
                    this.currentX++;
                    if (this.collision()) {
                        this.currentX = originalX - 1;
                        if (this.collision()) {
                            this.currentX = originalX;
                            this.currentPiece.shape = originalShape;
                        }
                    }
                }
            }
            
            rotateMatrix(matrix) {
                const rows = matrix.length;
                const cols = matrix[0].length;
                const rotated = Array(cols).fill().map(() => Array(rows).fill(0));
                
                for (let i = 0; i < rows; i++) {
                    for (let j = 0; j < cols; j++) {
                        rotated[j][rows - 1 - i] = matrix[i][j];
                    }
                }
                
                return rotated;
            }
            
            updateUI() {
                document.getElementById('score').textContent = this.score;
                document.getElementById('level').textContent = this.level;
                document.getElementById('lines').textContent = this.lines;
            }
            
            gameOver() {
                this.gameRunning = false;
                
                // Show game over overlay
                const gameOverDiv = document.createElement('div');
                gameOverDiv.innerHTML = `
                    <div style="
                        position: fixed;
                        top: 50%;
                        left: 50%;
                        transform: translate(-50%, -50%);
                        background: rgba(0, 0, 0, 0.95);
                        color: white;
                        padding: 40px;
                        border-radius: 20px;
                        text-align: center;
                        z-index: 200;
                        border: 3px solid #ff4444;
                    ">
                        <h2 style="color: #ff4444; font-size: 48px; margin-bottom: 20px;">GAME OVER</h2>
                        <div style="font-size: 24px; margin: 15px 0;">
                            <strong>Final Score: ${this.score}</strong>
                        </div>
                        <div style="font-size: 20px; margin: 10px 0;">
                            Level: ${this.level} | Lines: ${this.lines}
                        </div>
                        <button id="restartBtn" style="
                            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                            color: white;
                            border: none;
                            padding: 15px 30px;
                            font-size: 20px;
                            border-radius: 25px;
                            cursor: pointer;
                            margin-top: 20px;
                            font-weight: bold;
                        ">🔄 RESTART GAME</button>
                    </div>
                `;
                
                document.body.appendChild(gameOverDiv);
                
                document.getElementById('restartBtn').addEventListener('click', () => {
                    document.body.removeChild(gameOverDiv);
                    this.resetGame();
                });
                
                setTimeout(() => {
                    if (document.body.contains(gameOverDiv)) {
                        document.body.removeChild(gameOverDiv);
                        this.resetGame();
                    }
                }, 10000);
            }
            
            resetGame() {
                this.board = Array(20).fill().map(() => Array(10).fill(0));
                this.currentPiece = null;
                this.score = 0;
                this.level = 1;
                this.lines = 0;
                this.dropTime = 1000;
                this.updateUI();
                this.startGame();
            }
        }
        
        // Start the game when page loads
        window.addEventListener('load', () => {
            new ARTetris();
        });
        
    </script>
</body>
</html>
