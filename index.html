<!DOCTYPE html>
<html lang="en">
<head>
    <title>AR Tetris Pro</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="xr-spatial-tracking" content="true">
    
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, sans-serif;
            background: #000;
            color: white;
            touch-action: none;
        }

        /* Game Canvas */
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        /* UI Elements */
        #game-ui {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 1000;
            pointer-events: none;
        }

        .ui-panel {
            background: rgba(20, 20, 35, 0.85);
            padding: 8px 12px;
            border-radius: 8px;
            margin-bottom: 8px;
            font-size: 14px;
            border: 1px solid rgba(100, 180, 255, 0.2);
            backdrop-filter: blur(5px);
        }

        #next-piece {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 50px;
            height: 50px;
            background: rgba(20, 20, 35, 0.85);
            border-radius: 8px;
            border: 1px solid rgba(100, 180, 255, 0.2);
        }

        #ar-button {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(145deg, #6A11CB, #2575FC);
            color: white;
            border: none;
            padding: 14px 32px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 6px 20px rgba(37, 117, 252, 0.5);
            z-index: 1001;
            transition: all 0.3s ease;
        }

        #ar-button:hover {
            transform: translateX(-50%) scale(1.05);
            box-shadow: 0 8px 25px rgba(37, 117, 252, 0.7);
        }

        #placement-hint {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 14px 24px;
            border-radius: 10px;
            display: none;
            text-align: center;
            max-width: 80%;
        }

        #game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px 40px;
            border-radius: 16px;
            text-align: center;
            display: none;
            z-index: 1002;
            border: 2px solid rgba(255, 50, 50, 0.3);
        }

        #restart-button {
            background: linear-gradient(145deg, #00C853, #009624);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: 600;
            margin-top: 20px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <!-- Game UI -->
    <div id="game-ui">
        <div class="ui-panel">SCORE: <span id="score">0</span></div>
        <div class="ui-panel">LEVEL: <span id="level">1</span></div>
    </div>
    <div id="next-piece"></div>
    
    <!-- AR Controls -->
    <button id="ar-button">START AR EXPERIENCE</button>
    <div id="placement-hint">Move your device to scan a surface, then tap to place the game board</div>
    
    <!-- Game Over Screen -->
    <div id="game-over">
        <h2 style="color: #FF5555; margin-bottom: 20px;">GAME OVER</h2>
        <p>Your Final Score: <span id="final-score" style="font-weight: bold;">0</span></p>
        <button id="restart-button">PLAY AGAIN</button>
    </div>

    <!-- Audio Files -->
    <audio id="bgm" src="/music/music.mp3" loop></audio>
    <audio id="move-sfx" src="/music/tik.mp3"></audio>
    <audio id="clear-sfx" src="/music/lineclear.mp3"></audio>
    <audio id="gameover-sfx" src="/music/outro.mp3"></audio>

    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';

        // Game Constants
        const BOARD_SIZE = 2.0; // 2 meters in real world
        
        // Board dimensions (10x20 grid)
        const BOARD_WIDTH = 10;
        const BOARD_HEIGHT = 20;
        const BLOCK_SIZE = BOARD_SIZE / BOARD_WIDTH;
        
        // Tetromino shapes
        const SHAPES = [
            // I-piece
            [[1, 1, 1, 1]],
            // O-piece
            [[1, 1], [1, 1]],
            // T-piece
            [[0, 1, 0], [1, 1, 1]],
            // S-piece
            [[0, 1, 1], [1, 1, 0]],
            // Z-piece
            [[1, 1, 0], [0, 1, 1]],
            // L-piece
            [[1, 0], [1, 0], [1, 1]],
            // J-piece
            [[0, 1], [0, 1], [1, 1]]
        ];
        
        // Colors for each tetromino type
        const COLORS = [
            0x00F0F0, // I - Cyan
            0xF0F000, // O - Yellow
            0xA000F0, // T - Purple
            0x00F000, // S - Green
            0xF00000, // Z - Red
            0x0000F0, // L - Blue
            0xF0A000  // J - Orange
        ];
        
        // Level speeds (milliseconds between drops)
        const LEVEL_SPEEDS = [1000, 850, 700, 550, 450, 350, 280, 220, 180, 150];
        
        // Game Variables
        let renderer, scene, camera;
        let gameBoard, placementGrid;
        let currentPiece, nextPieceType;
        let hitTestSource = null;
        let grid = [];
        let score = 0, level = 1, gameActive = false;
        let gameLoopInterval = null;
        let audioEnabled = false;
        
        // DOM Elements
        const arButton = document.getElementById('ar-button');
        const placementHint = document.getElementById('placement-hint');
        const gameOverScreen = document.getElementById('game-over');
        const restartButton = document.getElementById('restart-button');
        const finalScoreElement = document.getElementById('final-score');
        
        // Initialize the game
        async function init() {
            // Initialize scene
            scene = new THREE.Scene();
            
            // Initialize camera
            camera = new THREE.PerspectiveCamera(
                70, 
                window.innerWidth / window.innerHeight, 
                0.01, 
                20
            );
            
            // Setup lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);
            
            // Initialize renderer
            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);
            
            // Create placement grid
            placementGrid = new THREE.Mesh(
                new THREE.PlaneGeometry(BOARD_SIZE, BOARD_SIZE),
                new THREE.MeshBasicMaterial({
                    color: 0x0099ff,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.5
                })
            );
            placementGrid.rotation.x = -Math.PI / 2; // Rotate to be horizontal
            placementGrid.visible = false;
            scene.add(placementGrid);
            
            // Create game board group
            gameBoard = new THREE.Group();
            
            // Initialize grid
            resetGrid();
            
            // Setup AR button
            const defaultARButton = ARButton.createButton(renderer, {
                requiredFeatures: ['hit-test'],
                optionalFeatures: ['dom-overlay']
            });
            defaultARButton.style.display = 'none';
            document.body.appendChild(defaultARButton);
            
            // Event listeners
            arButton.addEventListener('click', () => {
                defaultARButton.click();
                initAudio();
            });
            
            restartButton.addEventListener('click', restartGame);
            
            // Touch controls
            renderer.domElement.addEventListener('touchstart', handleTouch, { passive: false });
            
            // Handle AR session events
            renderer.xr.addEventListener('sessionstart', onSessionStart);
            renderer.xr.addEventListener('sessionend', onSessionEnd);
            
            // Start animation loop
            renderer.setAnimationLoop(animate);
            
            // Handle window resize
            window.addEventListener('resize', onWindowResize);
        }
        
        // Reset game grid
        function resetGrid() {
            grid = [];
            for (let row = 0; row < BOARD_HEIGHT; row++) {
                grid[row] = Array(BOARD_WIDTH).fill(0);
            }
        }
        
        // Handle AR session start
        async function onSessionStart() {
            const session = renderer.xr.getSession();
            
            // Request hit test source
            const referenceSpace = await session.requestReferenceSpace('viewer');
            hitTestSource = await session.requestHitTestSource({ space: referenceSpace });
            
            // Setup select event for placing board
            session.addEventListener('select', placeGameBoard);
            
            // Update UI
            arButton.style.display = 'none';
            placementHint.style.display = 'block';
        }
        
        // Handle AR session end
        function onSessionEnd() {
            // Cleanup game state
            resetGameState();
            location.reload();
        }
        
        // Reset game state
        function resetGameState() {
            clearInterval(gameLoopInterval);
            gameActive = false;
            score = 0;
            level = 1;
            
            // Remove all pieces
            while (gameBoard.children.length > 0) {
                gameBoard.remove(gameBoard.children[0]);
            }
            
            // Reset grid
            resetGrid();
            
            // Update UI
            document.getElementById('score').textContent = '0';
            document.getElementById('level').textContent = '1';
            gameOverScreen.style.display = 'none';
        }
        
        // Initialize audio
        function initAudio() {
            const bgm = document.getElementById('bgm');
            bgm.volume = 0.3;
            
            // Attempt to play and pause to unlock audio on mobile
            bgm.play().then(() => {
                bgm.pause();
                audioEnabled = true;
            }).catch(e => {
                console.log("Audio initialization failed:", e);
            });
        }
        
        // Play sound effect
        function playSound(id) {
            if (!audioEnabled) return;
            const sfx = document.getElementById(id);
            if (sfx) {
                sfx.currentTime = 0;
                sfx.play().catch(e => console.log("SFX error:", e));
            }
        }
        
        // Handle window resize
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // Main animation loop
        function animate(timestamp, frame) {
            if (frame && hitTestSource) {
                const hitTestResults = frame.getHitTestResults(hitTestSource);
                
                if (hitTestResults.length > 0 && !gameActive) {
                    const hit = hitTestResults[0];
                    const referenceSpace = renderer.xr.getReferenceSpace();
                    const pose = hit.getPose(referenceSpace);
                    
                    // Update placement grid position
                    placementGrid.matrix.fromArray(pose.transform.matrix);
                    placementGrid.visible = true;
                }
            }
            
            renderer.render(scene, camera);
        }
        
        // Place the game board in AR space
        function placeGameBoard() {
            if (gameActive) return;
            
            // Position game board at placement grid
            gameBoard.matrix.copy(placementGrid.matrix);
            
            // Center the board vertically
            gameBoard.position.y += BOARD_SIZE / 2;
            
            // Add game board to scene
            scene.add(gameBoard);
            
            // Hide placement grid
            placementGrid.visible = false;
            placementHint.style.display = 'none';
            
            // Start the game
            startGame();
        }
        
        // Start the game
        function startGame() {
            gameActive = true;
            
            // Initialize next piece
            nextPieceType = Math.floor(Math.random() * SHAPES.length);
            renderNextPiece();
            
            // Spawn first piece
            spawnPiece();
            
            // Start game loop
            gameLoopInterval = setInterval(() => {
                if (currentPiece) {
                    movePieceDown();
                }
            }, LEVEL_SPEEDS[level - 1]);
            
            // Play background music
            if (audioEnabled) {
                document.getElementById('bgm').play().catch(e => console.log("BGM error:", e));
            }
        }
        
        // Render next piece preview
        function renderNextPiece() {
            const canvas = document.getElementById('next-piece');
            const ctx = canvas.getContext('2d');
            
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Get shape information
            const shape = SHAPES[nextPieceType][0];
            const color = COLORS[nextPieceType];
            
            // Calculate block size
            const blockSize = Math.min(
                canvas.width / (shape[0].length + 2),
                canvas.height / (shape.length + 2)
            );
            
            // Calculate offset to center shape
            const offsetX = (canvas.width - shape[0].length * blockSize) / 2;
            const offsetY = (canvas.height - shape.length * blockSize) / 2;
            
            // Draw shape
            ctx.fillStyle = `#${color.toString(16).padStart(6, '0')}`;
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col]) {
                        ctx.fillRect(
                            offsetX + col * blockSize,
                            offsetY + row * blockSize,
                            blockSize - 2,
                            blockSize - 2
                        );
                    }
                }
            }
        }
        
        // Spawn a new piece
        function spawnPiece() {
            const typeIndex = nextPieceType;
            nextPieceType = Math.floor(Math.random() * SHAPES.length);
            renderNextPiece();
            
            const shape = SHAPES[typeIndex][0];
            const color = COLORS[typeIndex];
            
            const piece = new THREE.Group();
            piece.userData = {
                typeIndex,
                shape,
                rotation: 0,
                position: {
                    x: Math.floor(BOARD_WIDTH / 2 - shape[0].length / 2),
                    y: 0
                }
            };
            
            // Create piece geometry
            const blockGeometry = new THREE.BoxGeometry(
                BLOCK_SIZE * 0.9,
                BLOCK_SIZE * 0.9,
                BLOCK_SIZE * 0.9
            );
            
            const blockMaterial = new THREE.MeshPhongMaterial({
                color: color,
                shininess: 30,
                emissive: color,
                emissiveIntensity: 0.1
            });
            
            // Create individual blocks
            for (let row = 0; row < shape.length; row++) {
                for (let col = 0; col < shape[row].length; col++) {
                    if (shape[row][col]) {
                        const block = new THREE.Mesh(blockGeometry, blockMaterial);
                        block.position.set(
                            col * BLOCK_SIZE - (shape[0].length * BLOCK_SIZE) / 2 + BLOCK_SIZE / 2,
                            -row * BLOCK_SIZE + (shape.length * BLOCK_SIZE) / 2 - BLOCK_SIZE / 2,
                            0
                        );
                        piece.add(block);
                    }
                }
            }
            
            // Position the piece
            updatePiecePosition(piece);
            
            // Add to game board
            gameBoard.add(piece);
            currentPiece = piece;
            
            // Check if game over (piece can't be placed)
            if (!isValidMove(piece, 0, 0)) {
                gameOver();
            }
        }
        
        // Update piece position
        function updatePiecePosition(piece) {
            const ud = piece.userData;
            piece.position.set(
                (ud.position.x - BOARD_WIDTH / 2 + 0.5) * BLOCK_SIZE,
                (BOARD_HEIGHT / 2 - 0.5 - ud.position.y) * BLOCK_SIZE,
                0
            );
        }
        
        // Move piece down
        function movePieceDown() {
            if (isValidMove(currentPiece, 0, 1)) {
                currentPiece.userData.position.y += 1;
                updatePiecePosition(currentPiece);
            } else {
                lockPiece();
                spawnPiece();
            }
        }
        
        // Check if move is valid
        function isValidMove(piece, dx, dy) {
            const ud = piece.userData;
            const newX = ud.position.x + dx;
            const newY = ud.position.y + dy;
            
            // Check boundaries
            for (let row = 0; row < ud.shape.length; row++) {
                for (let col = 0; col < ud.shape[row].length; col++) {
                    if (ud.shape[row][col]) {
                        const boardX = newX + col;
                        const boardY = newY + row;
                        
                        // Check if out of bounds
                        if (boardX < 0 || boardX >= BOARD_WIDTH || boardY >= BOARD_HEIGHT) {
                            return false;
                        }
                        
                        // Check if collides with placed blocks
                        if (boardY >= 0 && grid[boardY][boardX] !== 0) {
                            return false;
                        }
                    }
                }
            }
            
            return true;
        }
        
        // Lock piece in place
        function lockPiece() {
            const ud = currentPiece.userData;
            
            // Add piece to grid
            for (let row = 0; row < ud.shape.length; row++) {
                for (let col = 0; col < ud.shape[row].length; col++) {
                    if (ud.shape[row][col]) {
                        const boardX = ud.position.x + col;
                        const boardY = ud.position.y + row;
                        
                        if (boardY >= 0 && boardY < BOARD_HEIGHT &&
                            boardX >= 0 && boardX < BOARD_WIDTH) {
                            grid[boardY][boardX] = ud.typeIndex + 1;
                        }
                    }
                }
            }
            
            // Remove current piece
            gameBoard.remove(currentPiece);
            currentPiece = null;
            
            // Check for line clears
            checkLineClears();
        }
        
        // Check for completed lines
        function checkLineClears() {
            let linesCleared = 0;
            let rowsToRemove = [];
            
            // Identify complete rows
            for (let row = 0; row < BOARD_HEIGHT; row++) {
                if (grid[row].every(cell => cell !== 0)) {
                    linesCleared++;
                    rowsToRemove.push(row);
                }
            }
            
            // Process line clears
            if (linesCleared > 0) {
                playSound('clear-sfx');
                
                // Score calculation
                const lineScores = [0, 100, 300, 500, 800];
                score += lineScores[linesCleared] * level;
                
                // Update score display
                document.getElementById('score').textContent = score.toString();
                
                // Remove complete rows
                rowsToRemove.sort((a, b) => a - b);
                for (const rowIndex of rowsToRemove) {
                    // Remove row from grid
                    grid.splice(rowIndex, 1);
                    grid.unshift(Array(BOARD_WIDTH).fill(0));
                    
                    // Remove corresponding blocks from game board
                    for (let i = gameBoard.children.length - 1; i >= 0; i--) {
                        const child = gameBoard.children[i];
                        if (child !== currentPiece) {
                            // Calculate the row of this block
                            const blockY = BOARD_HEIGHT - 1 - Math.floor(
                                (child.position.y + BOARD_HEIGHT * BLOCK_SIZE / 2) / BLOCK_SIZE
                            );
                            
                            if (Math.abs(blockY - rowIndex) < 0.5) {
                                gameBoard.remove(child);
                            } else if (blockY < rowIndex) {
                                // Move blocks above down
                                child.position.y += BLOCK_SIZE;
                            }
                        }
                    }
                }
                
                // Level up if score threshold reached
                if (score >= level * 2000 && level < LEVEL_SPEEDS.length) {
                    level++;
                    document.getElementById('level').textContent = level.toString();
                    
                    // Update game speed
                    clearInterval(gameLoopInterval);
                    gameLoopInterval = setInterval(() => {
                        if (currentPiece) {
                            movePieceDown();
                        }
                    }, LEVEL_SPEEDS[level - 1]);
                }
            }
        }
        
        // Game over handler
        function gameOver() {
            gameActive = false;
            clearInterval(gameLoopInterval);
            
            // Stop background music
            document.getElementById('bgm').pause();
            
            // Play game over sound
            playSound('gameover-sfx');
            
            // Show game over screen
            finalScoreElement.textContent = score.toString();
            gameOverScreen.style.display = 'block';
        }
        
        // Restart game
        function restartGame() {
            resetGameState();
            startGame();
        }
        
        // Handle touch inputs for controls
        function handleTouch(event) {
            if (!gameActive || !currentPiece) return;
            
            event.preventDefault();
            const touch = event.touches[0];
            const screenWidth = window.innerWidth;
            const touchX = touch.clientX;
            
            // Left side (move left)
            if (touchX < screenWidth * 0.3) {
                if (isValidMove(currentPiece, -1, 0)) {
                    currentPiece.userData.position.x -= 1;
                    updatePiecePosition(currentPiece);
                    playSound('move-sfx');
                }
            }
            // Right side (move right)
            else if (touchX > screenWidth * 0.7) {
                if (isValidMove(currentPiece, 1, 0)) {
                    currentPiece.userData.position.x += 1;
                    updatePiecePosition(currentPiece);
                    playSound('move-sfx');
                }
            }
            // Center (rotate)
            else {
                // Placeholder for rotation function
                playSound('move-sfx');
            }
        }
        
        // Start the game initialization
        init();
    </script>
</body>
</html>
