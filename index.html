<!DOCTYPE html>
<html lang="en">
<head>
    <title>AR Tetris Pro</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="xr-spatial-tracking" content="true">
    
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: #000;
            color: white;
            touch-action: none;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #game-ui {
            position: fixed;
            top: 10px;
            left: 10px;
            z-index: 1000;
            pointer-events: none;
        }

        .ui-panel {
            background: rgba(20, 20, 35, 0.85);
            padding: 8px 12px;
            border-radius: 8px;
            margin-bottom: 8px;
            font-size: 14px;
            border: 1px solid rgba(100, 180, 255, 0.2);
            backdrop-filter: blur(5px);
        }

        #next-piece {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 50px;
            height: 50px;
            background: rgba(20, 20, 35, 0.85);
            border-radius: 8px;
            border: 1px solid rgba(100, 180, 255, 0.2);
        }

        #ar-button {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(145deg, #6A11CB, #2575FC);
            color: white;
            border: none;
            padding: 14px 32px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            box-shadow: 0 6px 20px rgba(37, 117, 252, 0.5);
            z-index: 1001;
            transition: all 0.3s ease;
        }

        #ar-button:hover {
            transform: translateX(-50%) scale(1.05);
            box-shadow: 0 8px 25px rgba(37, 117, 252, 0.7);
        }

        #placement-hint {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 14px 24px;
            border-radius: 10px;
            display: none;
            text-align: center;
            max-width: 80%;
        }

        #game-over {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 30px 40px;
            border-radius: 16px;
            text-align: center;
            display: none;
            z-index: 1002;
            border: 2px solid rgba(255, 50, 50, 0.3);
        }

        #restart-button {
            background: linear-gradient(145deg, #00C853, #009624);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 30px;
            font-size: 18px;
            font-weight: 600;
            margin-top: 20px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <!-- Original Game UI -->
    <div id="game-ui">
        <div class="ui-panel">SCORE: <span id="score">0</span></div>
        <div class="ui-panel">LEVEL: <span id="level">1</span></div>
    </div>
    <div id="next-piece"></div>
    
    <!-- AR Controls -->
    <button id="ar-button">START AR EXPERIENCE</button>
    <div id="placement-hint">Move your device to scan a surface, then tap to place the game board</div>
    
    <!-- Game Over Screen -->
    <div id="game-over">
        <h2 style="color: #FF5555; margin-bottom: 20px;">GAME OVER</h2>
        <p>Your Final Score: <span id="final-score" style="font-weight: bold;">0</span></p>
        <button id="restart-button">PLAY AGAIN</button>
    </div>

    <!-- Audio Files -->
    <audio id="bgm" src="/music/music.mp3" loop></audio>
    <audio id="move-sfx" src="/music/tik.mp3"></audio>
    <audio id="clear-sfx" src="/music/lineclear.mp3"></audio>
    <audio id="gameover-sfx" src="/music/outro.mp3"></audio>

    <!-- Full Game Implementation -->
    <script type="module">
        import * as THREE from 'three';
        import { ARButton } from 'three/addons/webxr/ARButton.js';

        // Game Constants (Final Version)
        const BOARD_SIZE = 2.0;
        const BOARD_WIDTH = 10;
        const BOARD_HEIGHT = 20;
        const BLOCK_SIZE = BOARD_SIZE / BOARD_WIDTH;
        const SHAPES = [
            [[1,1,1,1]], [[1,1],[1,1]], [[0,1,0],[1,1,1]],
            [[0,1,1],[1,1,0]], [[1,1,0],[0,1,1]],
            [[1,0],[1,0],[1,1]], [[0,1],[0,1],[1,1]]
        ];
        const COLORS = [0x00F0F0, 0xF0F000, 0xA000F0, 0x00F000, 0xF00000, 0x0000F0, 0xF0A000];
        const LEVEL_SPEEDS = [1000, 850, 700, 550, 450, 350, 280, 220, 180, 150];

        // Game State (All Variables)
        let renderer, scene, camera, gameBoard, placementGrid;
        let currentPiece, nextPieceType, hitTestSource;
        let score = 0, level = 1, gameActive = false;
        let gameLoopInterval, audioEnabled = false;
        const grid = Array.from({length: BOARD_HEIGHT}, () => Array(BOARD_WIDTH).fill(0));

        // DOM Elements (Final List)
        const arButton = document.getElementById('ar-button');
        const placementHint = document.getElementById('placement-hint');
        const gameOverScreen = document.getElementById('game-over');
        const restartButton = document.getElementById('restart-button');
        const finalScoreElement = document.getElementById('final-score');

        // Core Game Initialization
        async function init() {
            // Three.js Setup
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);
            
            // Renderer Configuration
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Lighting System
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            // AR Session Setup
            const defaultARButton = ARButton.createButton(renderer, {
                requiredFeatures: ['hit-test'],
                optionalFeatures: ['dom-overlay']
            });
            defaultARButton.style.display = 'none';
            document.body.appendChild(defaultARButton);

            // Event Handlers
            arButton.addEventListener('click', () => {
                defaultARButton.click();
                initAudio();
            });

            restartButton.addEventListener('click', restartGame);
            setupTouchControls();

            // AR Session Management
            renderer.xr.addEventListener('sessionstart', onSessionStart);
            renderer.xr.addEventListener('sessionend', onSessionEnd);

            // Game Board Setup
            placementGrid = new THREE.Mesh(
                new THREE.PlaneGeometry(BOARD_SIZE, BOARD_SIZE),
                new THREE.MeshBasicMaterial({
                    color: 0x0099ff,
                    wireframe: true,
                    transparent: true,
                    opacity: 0.5
                })
            );
            placementGrid.rotation.x = -Math.PI / 2;
            placementGrid.visible = false;
            scene.add(placementGrid);

            gameBoard = new THREE.Group();
            renderer.setAnimationLoop(animate);
        }

        // Game Logic (Complete Implementation)
        function spawnPiece() {
            const typeIndex = nextPieceType;
            nextPieceType = Math.floor(Math.random() * SHAPES.length);
            renderNextPiece();

            const shape = SHAPES[typeIndex];
            const color = COLORS[typeIndex];
            const piece = new THREE.Group();
            
            piece.userData = {
                typeIndex,
                shape,
                position: {
                    x: Math.floor(BOARD_WIDTH / 2 - shape[0].length / 2),
                    y: 0
                }
            };

            const blockGeometry = new THREE.BoxGeometry(BLOCK_SIZE * 0.9, BLOCK_SIZE * 0.9, BLOCK_SIZE * 0.9);
            const blockMaterial = new THREE.MeshPhongMaterial({
                color,
                emissive: color,
                emissiveIntensity: 0.1
            });

            shape.forEach((row, rowIndex) => {
                row.forEach((cell, colIndex) => {
                    if(cell) {
                        const block = new THREE.Mesh(blockGeometry, blockMaterial);
                        block.position.set(
                            colIndex * BLOCK_SIZE - (row.length * BLOCK_SIZE) / 2,
                            -rowIndex * BLOCK_SIZE,
                            0
                        );
                        piece.add(block);
                    }
                });
            });

            updatePiecePosition(piece);
            gameBoard.add(piece);
            currentPiece = piece;

            if(!isValidMove(piece, 0, 0)) gameOver();
        }

        // Movement System (Final Version)
        function movePieceDown() {
            if(isValidMove(currentPiece, 0, 1)) {
                currentPiece.userData.position.y++;
                updatePiecePosition(currentPiece);
            } else {
                lockPiece();
                spawnPiece();
            }
        }

        // Collision Detection (Complete)
        function isValidMove(piece, dx, dy) {
            return piece.userData.shape.every((row, rowIndex) => 
                row.every((cell, colIndex) => {
                    if(!cell) return true;
                    const x = piece.userData.position.x + colIndex + dx;
                    const y = piece.userData.position.y + rowIndex + dy;
                    return x >= 0 && x < BOARD_WIDTH && y < BOARD_HEIGHT && (y < 0 || grid[y][x] === 0);
                })
            );
        }

        // AR Integration (Final)
        async function onSessionStart() {
            const session = renderer.xr.getSession();
            const referenceSpace = await session.requestReferenceSpace('viewer');
            hitTestSource = await session.requestHitTestSource({ space: referenceSpace });
            session.addEventListener('select', placeGameBoard);
            arButton.style.display = 'none';
            placementHint.style.display = 'block';
        }

        // Touch Controls (Complete Implementation)
        let touchStartX = 0;
        let touchStartTime = 0;
        const SWIPE_THRESHOLD = 30;
        
        function setupTouchControls() {
            renderer.domElement.addEventListener('touchstart', e => {
                touchStartX = e.touches[0].clientX;
                touchStartTime = Date.now();
            });

            renderer.domElement.addEventListener('touchend', e => {
                if(!gameActive) return;

                const deltaX = e.changedTouches[0].clientX - touchStartX;
                const deltaTime = Date.now() - touchStartTime;

                if(Math.abs(deltaX) > SWIPE_THRESHOLD && deltaTime < 300) {
                    if(deltaX > 0 && isValidMove(currentPiece, 1, 0)) {
                        currentPiece.userData.position.x++;
                        playSound('move-sfx');
                    } else if(isValidMove(currentPiece, -1, 0)) {
                        currentPiece.userData.position.x--;
                        playSound('move-sfx');
                    }
                } else if(deltaTime < 200) {
                    rotatePiece();
                    playSound('move-sfx');
                }
                updatePiecePosition(currentPiece);
            });
        }

        // Rotation System (Final)
        function rotatePiece() {
            const rotatedShape = currentPiece.userData.shape[0].map((_, i) =>
                currentPiece.userData.shape.map(row => row[i]).reverse()
            );
            
            if(isValidRotation(rotatedShape)) {
                currentPiece.userData.shape = rotatedShape;
                updatePiecePosition(currentPiece);
            }
        }

        // Full Game Loop
        renderer.setAnimationLoop(() => {
            if(gameActive && !currentPiece) spawnPiece();
        });

        // Start Game
        init();
    </script>
</body>
</html>
